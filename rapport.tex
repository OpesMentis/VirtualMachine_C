\documentclass[11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[scale=1, top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{listings}
\usepackage{courier}

\begin{document}
	\title{Architecture numérique}
	\author{Antoine \bsc{Planchot} et Julien \bsc{Tomezach}}
	\maketitle

	\part*{Introduction}
	\paragraph{}
	L'objectif de ce projet est la réalisation d'une machine virtuelle d'un microprocesseur en langage C. Le tout se décompose en deux programmes comme autant d'étapes nécessaire à l'accomplissement de cet objectif. Le tout se décompose donc comme suit~:

	\begin{itemize}
		\item la conversion d'un code en assembleur dans un fichier texte quelconque vers le fichier binaire~;
		\item la conversion du fichier binaire vers l'exécution de la machine virtuelle, en C.
	\end{itemize}

	\paragraph{}
	Une nomenclature commune ayant été établie, à laquelle on pourra se référer à tout moment dans la partie dédiée, nous pûmes nous mettre au travail.

	\part*{Encodage des informations binaires}
	\paragraph{}
	Il a été entendu au préalable que chaque instruction écrite en langage d'assemblage sera encodée sur 32 bits suivant le schéma générique suivant.

	\begin{table}[h]
		\centering
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|}
			\hline
			\multicolumn{5}{|l|}{\textbf{Fonction}} & \multicolumn{5}{l|}{\textbf{Registre 1}} & \textbf{Flag} & \multicolumn{16}{l|}{\textbf{Paramètre o}} & \multicolumn{5}{l|}{\textbf{Registre 2}} \\ \hline
			\multicolumn{5}{|l|}{5 bits} & \multicolumn{5}{l|}{5 bits} & 1 bit & \multicolumn{16}{l|}{16 bits} & \multicolumn{5}{l|}{5 bits} \\ \hline
		\end{tabular}
	\end{table}

	\paragraph{}
	Le \textit{flag} indique comment considérer le paramètre \verb?o?. Si le \textit{flag} vaut 0, on lit \verb?o? comme une constante numérique. S'il vaut 1, \verb?o? se rapporte au registre ayant cette adresse.
	\paragraph{}
	Ce schéma sera adapté selon les exigences de la fonction, comme son nombre de paramètres ou l'ordre d'appel des dits paramètres.

	\part*{De l'assembleur vers le binaire}
	\paragraph{}
	Outre les problèmes inhérents au langage C, nous n'avons n'a pas rencontré de problème majeur, si ce n'est que le cheminement vers un code purgé de toutes ses erreurs et capable de répondre à toutes les éventualités ne s'est pas faite sans douleur.
	\paragraph{}
	En effet, le langage d'assemblage ici considéré a ses subtilités. Les fonctions ne reçoivent pas tous le même nombre de paramètres et le rôle de ses paramètres va changer selon la fonction appelée. Dès lors, une approche générique semble difficile au moment de la traduction en binaire des instructions. Néanmoins, on parvient à ses fins grâce à des fonctions de haut niveau (\verb?add_register? et \verb?add_flag_argO?) qui parmettent d'ajouter les bits de registre, de flag et du paramètre o. On reconnaîtra ainsi cinq grands type de commande se traduisant de la même façon~: \textit{add like}, \textit{jump}, \textit{braz like}, \textit{scall like} et \textit{stop}.
	\paragraph{}
	Les bits que l'on sait non lus prendront par défaut la valeur 1. Néanmoins, quand le besoin se présente de compléter une commande, cela se fait par des zéros.

	\part*{Du binaire vers la machine virtuelle}
	\paragraph{}
	Les instructions étant formalisées en binaire, il convient maintenant de les faire s'exécuter. Au préalable, on a pris soin de créer deux tableaux d'entiers, simulant les registres et la mémoire de données. Par ailleurs, on initialise le 30\up{ème} registre à 500, en sa qualité de \textit{stack pointer}.

	\paragraph{}
	Une structure \verb?struct cmd? permet de stocker proprement les informations extraites d'une ligne d'instruction et de faciliter son traitement. On notera que quelque soit la fonction considérée, qu'ils soient pris en compte ou pas, tous les paramètres sont systématiquement lus pour faciliter l'exécution.

	\paragraph{}
	Plusieurs fonctions de haut niveau ayant été codées au préalable, on peut à présent faire tourner la machine en se véhiculant à travers le code. Le \textit{program counter} permet de guider la tête de lecture dans le fichier binaire. Par défaut, on se contente de l'incrémenter mais certaines fonctions comme \verb?jump? obligent à des sauts plus exotiques.

	\paragraph{}
	Le programme s'arrête quand il rencontre l'instruction \verb?stop?. L'oubli de cette commande à la fin d'un programme conduit à un plantage quasi-inéluctable lors de l'exécution. Il doit s'agir là d'ailleurs d'un des principals défauts de la machine virtuelle telle qu'elle est codée~: la presque totale absence de gestion des erreurs. Notamment lors du débuggage de nos codes, il nous était difficile de distinguer les origines des erreurs, soit dans notre code, soit dans le programme de test d'origine, soit dans le code binaire préalablement généré.

	\part*{Conclusion}
	\paragraph{}
	Les programmes, en l'état actuel des choses, s'exécutent normalement. Ils ont été testé sur un court programme de calcul de la fonction factorielle disponible à \verb,data/ex_code,. Ci-dessous, les différentes étapes de traitement.

	\begin{table}[h]
	\centering
	\begin{tabular}{ll|ll|l}
		\lstinputlisting{data/ex_code} & & \lstinputlisting{data/bin.txt} & & \lstinputlisting[basicstyle=\small\ttfamily,breaklines=true]{data/exec} \\ \\
		\hline
		\\
		\textbf{Assembleur} & & \textbf{Binaire} & & \textbf{Machine virtuelle}
	\end{tabular}
	\end{table}

\end{document}
